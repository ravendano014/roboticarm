<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>Robotic Arm 3D Control</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    canvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
    
    /* Panel de controles */
    .control-panel {
      position: absolute;
      background: rgba(30, 30, 40, 0.85);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      color: white;
      z-index: 10;
    }
    
    .control-panel.left {
      left: 15px;
      top: 15px;
      width: 220px;
    }
    
    .control-panel.right {
      right: 15px;
      top: 15px;
      width: 240px;
    }
    
    .control-panel.bottom-right {
      right: 15px;
      bottom: 15px;
      width: 240px;
    }
    
    .control-group {
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 10px;
    }
    
    .control-group:last-child {
      border-bottom: none;
    }
    
    .control-group h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      font-weight: 500;
      color: #7fdbff;
      display: flex;
      align-items: center;
    }
    
    .control-group h3 i {
      margin-right: 8px;
      font-size: 16px;
    }
    
    .button-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    
    .control-button {
      flex: 1;
      margin: 0 4px;
      padding: 8px 0;
      background: rgba(70, 70, 90, 0.7);
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 50px;
    }
    
    .control-button:hover {
      background: rgba(90, 90, 120, 0.9);
      transform: translateY(-2px);
    }
    
    .control-button:active {
      transform: translateY(0);
    }
    
    .control-button i {
      font-size: 18px;
      margin-bottom: 5px;
    }
    
    .control-button span {
      font-size: 12px;
    }
    
    .slider-container {
      padding: 10px 0;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 12px;
    }
    
    .slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #7fdbff;
      cursor: pointer;
    }
    
    /* Etiquetas de estado */
    .status-label {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 12px;
      display: flex;
      align-items: center;
    }
    
    .status-label i {
      margin-right: 8px;
    }
    
    /* Modo responsivo */
    @media (max-width: 768px) {
      .control-panel {
        padding: 8px;
      }
      
      .control-panel.left {
        width: 180px;
      }
      
      .control-panel.right, 
      .control-panel.bottom-right {
        width: 180px;
      }
      
      .control-button {
        padding: 6px 0;
        min-height: 40px;
      }
      
      .control-button i {
        font-size: 16px;
      }
      
      .control-button span {
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  
  <div class="control-panel left" id="armControls">
    
    <div class="control-group">
      <h3><i class="fas fa-cogs"></i> Gears</h3>
      <div class="slider-container">
        <input type="range" min="-1.0" max="1.0" step="0.01" value="0" class="slider" id="gearSlider">
      </div>
    </div>
  
    <div class="control-group" style="display: none;">
      <h3><i class="fas fa-grip-lines"></i> Gripper Open/Close</h3>
      <div class="slider-container">
        <input type="range" min="-0.5" max="0.5" step="0.01" value="0" class="slider" id="gripperOpenCloseSlider">
      </div>
    </div>

    <div class="control-group">
      <h3><i class="fas fa-hand-paper"></i> Gripper Pitch</h3>
      <div class="slider-container">
        <input type="range" min="-1.5" max="1.5" step="0.01" value="0" class="slider" id="gripPitchSlider">
      </div>
    </div>

    <div class="control-group">
      <h3><i class="fas fa-robot"></i> Arm 3</h3>
      <div class="slider-container">
        <input type="range" min="-1.5" max="1.5" step="0.01" value="0" class="slider" id="arm3Slider">
      </div>
    </div>

    <div class="control-group">
      <h3><i class="fas fa-robot"></i> Arm 2</h3>
      <div class="slider-container">
        <input type="range" min="-1.5" max="1.5" step="0.01" value="0" class="slider" id="arm2Slider">
      </div>
    </div>

    <div class="control-group">
      <h3><i class="fas fa-robot"></i> Arm 1</h3>
      <div class="slider-container">
        <input type="range" min="-1.5" max="1.5" step="0.01" value="0" class="slider" id="arm1Slider">
      </div>
    </div>

    <div class="control-group" style="display: none;">
      <h3><i class="fas fa-link"></i> Grip Links</h3>
      <div class="slider-container">
        <input type="range" min="-0.5" max="0.5" step="0.01" value="0" class="slider" id="linkAdjustSlider">
      </div>
    </div>



    <div class="control-group">
      <h3><i class="fas fa-undo-alt"></i> Waist Rotation</h3>
      <div class="slider-container">
        <input type="range" min="-3.14" max="3.14" step="0.01" value="0" class="slider" id="waistSlider">
      </div>
    </div>

    <div class="control-group">
      <h3><i class="fas fa-sliders-h"></i> Speed Control</h3>
      <div class="slider-container">
        <div class="slider-label">
          <span>Slow</span>
          <span>Fast</span>
        </div>
        <input type="range" min="0.01" max="0.1" step="0.01" value="0.04" class="slider" id="speedSlider">
      </div>
    </div>

  </div>
  
  <div class="control-panel right" id="routineControls">
    <div class="control-group">
      <h3><i class="fas fa-project-diagram"></i> Routine Controls</h3>
      <div class="button-row">
        <button class="control-button" id="capturePosition">
          <i class="fas fa-camera"></i>
          <span>Capture</span>
        </button>
        <button class="control-button" id="startRoutine">
          <i class="fas fa-play"></i>
          <span>Start</span>
        </button>
      </div>
      <div class="button-row">
        <button class="control-button" id="stopRoutine">
          <i class="fas fa-stop"></i>
          <span>Stop</span>
        </button>
        <button class="control-button" id="resetRoutine">
          <i class="fas fa-trash-alt"></i>
          <span>Reset</span>
        </button>
      </div>
      <div class="button-row">
        <button class="control-button" id="replayRoutine">
          <i class="fas fa-redo"></i>
          <span>Replay</span>
        </button>
      </div>
    </div>
  </div>
  
  <div class="control-panel bottom-right" id="cameraControls">
    <div class="control-group">
      <h3><i class="fas fa-video"></i> Camera Views</h3>
      <div class="button-row">
        <button class="control-button" id="defaultView">
          <i class="fas fa-globe"></i>
          <span>Default</span>
        </button>
      </div>
      <div class="button-row">
        <button class="control-button" id="frontView">
          <i class="fas fa-arrow-up"></i>
          <span>Front</span>
        </button>
        <button class="control-button" id="topView">
          <i class="fas fa-arrow-down"></i>
          <span>Top</span>
        </button>
      </div>
      <div class="button-row">
        <button class="control-button" id="sideView">
          <i class="fas fa-arrow-right"></i>
          <span>Side</span>
        </button>
      </div>
    </div>
  </div>
  
  <div class="status-label" id="statusLabel">
    <i class="fas fa-circle-notch fa-spin"></i>
    <span>System Ready</span>
  </div>

  <script>
    // Global configuration
    const CONFIG = {
      rotationSpeed: 0.04,
      modelBaseUrl: "https://raw.githubusercontent.com/ravendano014/roboticarm/main/models/",
      groundTextureUrl: "http://upload.wikimedia.org/wikipedia/commons/4/45/Blender3D_BW_Grid_256.png"
    };

    // Variable to hold the camera instance
    let camera;

    // Engine initialization
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    
    // Variables to store routine movements
    const servoRotations = [];
    let isRoutineRunning = false;
    let currentRoutineStep = 0;
    let routineAnimationTimeout = null;
    let routineAnimationRequestId = null;
    const transitionDuration = 700;

    // Camera presets
    const cameraPresets = {
        "Default": {
            alpha: Math.PI / 1.33,
            beta: 0.9,
            radius: 500, 
            target: new BABYLON.Vector3(0, 100, 0)
        },
        "Front View": {
            alpha: Math.PI, 
            beta: Math.PI / 2, 
            radius: 500, 
            target: new BABYLON.Vector3(0, -40, 0)
        },
        "Top View": {
            alpha: Math.PI / 2, 
            beta: 0.1, 
            radius: 500, 
            target: new BABYLON.Vector3(0, 20, 0)
        },
        "Side View": {
            alpha: Math.PI / 2, 
            beta: Math.PI / 2,
            radius: 500, 
            target: new BABYLON.Vector3(0, -40, 0)
        }
    };

    // Function to update status
    const updateStatus = (message, isError = false) => {
      const statusLabel = document.getElementById("statusLabel");
      statusLabel.innerHTML = `<i class="fas fa-${isError ? 'exclamation-circle' : 'check-circle'}"></i><span>${message}</span>`;
      
      if (isError) {
        statusLabel.style.color = '#ff6b6b';
      } else {
        statusLabel.style.color = 'white';
      }
      
      if (!isError) {
        setTimeout(() => {
          statusLabel.innerHTML = `<i class="fas fa-circle-notch fa-spin"></i><span>System Ready</span>`;
          statusLabel.style.color = 'white';
        }, 3000);
      }
    };

    // Camera setup
    const setupCamera = (scene) => {
      const cam = new BABYLON.ArcRotateCamera(
        "Camera",
        Math.PI / 1.33,
        0.9,
        500, 
        new BABYLON.Vector3(0, 100, 0),
        scene
      );
      cam.attachControl(canvas, false);
      return cam;
    };

    // Light setup
    const setupLight = (scene) => {
      return new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    };

    // Ground setup
    const setupGround = (scene) => {
      const ground = BABYLON.Mesh.CreateGround("ground", 100, 100, 1, scene);
      const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
      groundMat.diffuseTexture = new BABYLON.Texture(CONFIG.groundTextureUrl, scene);
      groundMat.specularColor = BABYLON.Color3.Black();
      ground.material = groundMat;
      return ground;
    };

    // Basic arm components creation
    const createArmComponents = (scene) => {
      const components = {};
      
      // Base
      components.base = BABYLON.MeshBuilder.CreateCylinder("base", { height: 0.2, diameter: 4 }, scene);
      components.base.position.y = 0.1;
      components.base.material = createMaterial(scene, new BABYLON.Color3(0.2, 0.2, 0.2));
      
      // Waist
      components.waist = BABYLON.MeshBuilder.CreateBox("waist", { width: 2, height: 0.2, depth: 1 }, scene);
      components.waist.position.y = 0.1;
      components.waist.parent = components.base;
      components.waist.material = createMaterial(scene, new BABYLON.Color3(0.4, 0.4, 0.4));
      
      // Servos and arms
      components.servo01 = createDisc("servo01", 0.5, new BABYLON.Vector3(-10, 95, 14), components.waist, scene);
      components.arm01 = createBox("arm01", { width: 1, height: 3, depth: 1 }, new BABYLON.Vector3(0, 1.5, 0), components.servo01, scene);
      
      components.servo02 = createDisc("servo02", 0.3, new BABYLON.Vector3(0, 120, 0), components.arm01, scene);
      components.arm02 = createBox("arm02", { width: 1, height: 3, depth: 1 }, new BABYLON.Vector3(0, 1.5, 0), components.servo02, scene);
      
      components.servo03 = createDisc("servo03", 0.3, new BABYLON.Vector3(0, 0, 85), components.arm02, scene);
      components.arm03 = createBox("arm03", { width: 1, height: 1, depth: 1 }, new BABYLON.Vector3(0, 0.5, 0), components.servo03, scene);
      
      // Gripper
      components.grip = createBox("grip", { width: 1, height: 1, depth: 1 }, new BABYLON.Vector3(0, 0, 33), components.arm03, scene);
      components.servo04 = createDisc("servo04", 0.3, new BABYLON.Vector3(0, 0, 33), components.grip, scene);
      
      components.gripperbase = createBox("gripper", { width: 1, height: 1, depth: 1 }, new BABYLON.Vector3(0, 0, 33), components.grip, scene);
      components.gear1 = createBox("gear1", { width: 1, height: 1, depth: 1 }, new BABYLON.Vector3(22, -43, -25), components.gripperbase, scene);
      components.gear2 = createBox("gear2", { width: 1, height: 1, depth: 1 }, new BABYLON.Vector3(-7, -43, -25), components.gripperbase, scene);
      components.gearl = createBox("gear", { width: 1, height: 1, depth: 1 }, new BABYLON.Vector3(0, 0, 33), components.gear1, scene);
      components.gearr = createBox("gear", { width: 1, height: 1, depth: 1 }, new BABYLON.Vector3(0, 0, 33), components.gear2, scene);
      components.servo05 = createDisc("servo05", 0.3, new BABYLON.Vector3(0, 0, 83), components.gripperbase, scene);
      components.gripper = createBox("gripper", { width: 1, height: 1, depth: 1 }, new BABYLON.Vector3(0, 0, 33), components.gearl, scene);
      
      // New components for grip links
      components.gripLinkLeft1 = createBox("gripLinkLeft1", { width: 0.5, height: 0.5, depth: 2 }, new BABYLON.Vector3(0.5, 0, 0), components.gripperbase, scene);
      components.gripLinkLeft2 = createBox("gripLinkLeft2", { width: 0.5, height: 0.5, depth: 2 }, new BABYLON.Vector3(0.5, 0, 0), components.gripperbase, scene);
      components.gripLinkRight1 = createBox("gripLinkRight1", { width: 0.5, height: 0.5, depth: 2 }, new BABYLON.Vector3(-0.5, 0, 0), components.gripperbase, scene);
      components.gripLinkRight2 = createBox("gripLinkRight2", { width: 0.5, height: 0.5, depth: 2 }, new BABYLON.Vector3(-0.5, 0, 0), components.gripperbase, scene);
      

      return components;
    };

    // Helper functions to create components
    const createMaterial = (scene, color) => {
      const mat = new BABYLON.StandardMaterial("mat", scene);
      mat.diffuseColor = color;
      return mat;
    };

    const createDisc = (name, radius, position, parent, scene) => {
      const disc = BABYLON.MeshBuilder.CreateDisc(name, { radius, tessellation: 50 }, scene);
      disc.position = position;
      disc.parent = parent;
      disc.material = createMaterial(scene, new BABYLON.Color3(0.6, 0.6, 0.6));
      return disc;
    };

    const createBox = (name, options, position, parent, scene) => {
      const box = BABYLON.MeshBuilder.CreateBox(name, options, scene);
      box.position = position;
      box.parent = parent;
      box.material = createMaterial(scene, new BABYLON.Color3(0.8, 0.8, 0.8));
      return box;
    };

    // STL models loading
    const loadSTLModels = (scene, components) => {
      const modelConfigs = [
        { name: "Base.STL", parent: components.base, position: [-60, 0, 60], rotation: [-1.5707963267948966, 0, 0], color: [0.5, 0.5, 0.5] },
        { name: "Waist.STL", parent: components.waist, position: [-48, 56, 48], rotation: [-1.5707963267948966, 0, 0], color: [0.8, 0.8, 0.8] },
        { name: "Arm%2001.STL", parent: components.arm01, position: [7, -26, -29], rotation: [-1.5707963267948966, 0, -1.5707963267948966], color: [1, 0, 0] },
        { name: "Arm%2002.STL", parent: components.arm02, position: [12, -20, -24], rotation: [0, 0, 1.5707963267948966], color: [0.5, 0.5, 0.5] },
        { name: "Arm%2003.STL", parent: components.arm03, position: [12, -20, 6], rotation: [0, 0, 1.5707963267948966], color: [0.8, 0.8, 0.8] },
        { name: "Gripper%20base.STL", parent: components.grip, position: [26, 9, -15], rotation: [0, 0, 3.141592653589793], color: [1, 0, 0] },
        { name: "gear1.STL", parent: components.gear1, position: [-16, -16, 5], rotation: [0, 0, 0], color: [0, 1, 0] },
        { name: "gear2.STL", parent: components.gear2, position: [-26, -29, 5], rotation: [0, 0, 0.45], color: [0, 0, 1] },
        { name: "grip%20link%201.STL", parent: components.gearl, position: [45, -16, -40], rotation: [0, 0, 3.141592653589793], color: [0, 1, 0] },
        { name: "grip%20link%201.STL", parent: components.gearr, position: [-4, -18, -40], rotation: [0, 0, 3.40], color: [0, 0.5, 0] },
        { name: "grip%20link%201.STL", parent: components.gearl, position: [45, -16, -27], rotation: [0, 0, 3.141592653589793], color: [0, 1, 0] },
        { name: "grip%20link%201.STL", parent: components.gearr, position: [-4, -18, -27], rotation: [0, 0, 3.40], color: [0, 0.5, 0] },
        { name: "Gripper%201.STL", parent: components.gearl, position: [50, -58, -28], rotation: [3.55, -Math.PI/2, 3.141592653589793], color: [0, 1, 0] },
        { name: "Gripper%201.STL", parent: components.gearr, position: [-42, -70, -36], rotation: [-0.25, -Math.PI/2, 0], color: [0, 0, 1] }
      ];

      modelConfigs.forEach(config => {
        BABYLON.SceneLoader.ImportMesh(
          "", 
          CONFIG.modelBaseUrl, 
          config.name, 
          scene, 
          (newMeshes) => setupImportedMesh(newMeshes[0], config, scene)
        );
      });
    };

    const setupImportedMesh = (mesh, config, scene) => {
      mesh.setPivotPoint(new BABYLON.Vector3(0, 0, 0));
      mesh.parent = config.parent;
      mesh.position = new BABYLON.Vector3(...config.position);
      mesh.rotation = new BABYLON.Vector3(...config.rotation);
      mesh.material = new BABYLON.StandardMaterial("importedMeshMaterial", scene);
      mesh.material.diffuseColor = new BABYLON.Color3(...config.color);
    };

    // Routine functions
    const setRotation = (components) => {
        const capturedState = {
            waist: { x: components.waist.rotation.x, y: components.waist.rotation.y, z: components.waist.rotation.z },
            servo01: { x: components.servo01.rotation.x, y: components.servo01.rotation.y, z: components.servo01.rotation.z },
            servo02: { x: components.servo02.rotation.x, y: components.servo02.rotation.y, z: components.servo02.rotation.z },
            servo03: { x: components.servo03.rotation.x, y: components.servo03.rotation.y, z: components.servo03.rotation.z },
            servo04: { x: components.servo04.rotation.x, y: components.servo04.rotation.y, z: components.servo04.rotation.z },
            servo05: { x: components.servo05.rotation.x, y: components.servo05.rotation.y, z: components.servo05.rotation.z },
            gearl: { x: components.gearl.rotation.x, y: components.gearl.rotation.y, z: components.gearl.rotation.z },
            gearr: { x: components.gearr.rotation.x, y: components.gearr.rotation.y, z: components.gearr.rotation.z },
            gear1: { x: components.gear1.rotation.x, y: components.gear1.rotation.y, z: components.gear1.rotation.z },
            gear2: { x: components.gear2.rotation.x, y: components.gear2.rotation.y, z: components.gear2.rotation.z },
            gripLinkLeft1: { x: components.gripLinkLeft1.rotation.x, y: components.gripLinkLeft1.rotation.y, z: components.gripLinkLeft1.rotation.z },
            gripLinkLeft2: { x: components.gripLinkLeft2.rotation.x, y: components.gripLinkLeft2.rotation.y, z: components.gripLinkLeft2.rotation.z },
            gripLinkRight1: { x: components.gripLinkRight1.rotation.x, y: components.gripLinkRight1.rotation.y, z: components.gripLinkRight1.rotation.z },
            gripLinkRight2: { x: components.gripLinkRight2.rotation.x, y: components.gripLinkRight2.rotation.y, z: components.gripLinkRight2.rotation.z }
        };
        servoRotations.push(capturedState);
        updateStatus(`Position captured (Step ${servoRotations.length})`);
    };

    const stopRoutine = () => {
        isRoutineRunning = false;
        if (routineAnimationRequestId) {
            cancelAnimationFrame(routineAnimationRequestId);
            routineAnimationRequestId = null;
        }
        if (routineAnimationTimeout) {
            clearTimeout(routineAnimationTimeout);
            routineAnimationTimeout = null;
        }
        updateStatus("Routine stopped");
    };

    const resetRotations = () => {
        stopRoutine();
        servoRotations.length = 0;
        currentRoutineStep = 0;
        updateStatus("Routine reset");
    };

    const executeRoutine = (components) => {
        if (!isRoutineRunning) {
            console.log("Routine not started or stopped.");
            return;
        }

        if (servoRotations.length === 0) {
            console.log("No routine movements recorded.");
            isRoutineRunning = false;
            return;
        }

        if (currentRoutineStep >= servoRotations.length) {
            currentRoutineStep = 0;
            console.log("Routine completed one cycle. Restarting.");
            routineAnimationTimeout = setTimeout(() => executeRoutine(components), 100); 
            return;
        }

        const targetRotations = servoRotations[currentRoutineStep];
        const componentsToAnimate = [
            "waist", "servo01", "servo02", "servo03", "servo04", "servo05",
            "gearl", "gearr", "gripLinkLeft1", "gripLinkLeft2", "gripLinkRight1", "gripLinkRight2", "gear1", "gear2"
        ];

        const startRotations = {};
        componentsToAnimate.forEach(name => {
            const mesh = components[name];
            startRotations[name] = new BABYLON.Vector3(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z);
        });

        let startTime = null;

        const animateStep = (timestamp) => {
            if (!isRoutineRunning) {
                if (routineAnimationRequestId) cancelAnimationFrame(routineAnimationRequestId);
                routineAnimationRequestId = null;
                return;
            }

            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;
            const progress = Math.min(elapsed / transitionDuration, 1);

            componentsToAnimate.forEach(name => {
                const mesh = components[name];
                const startRot = startRotations[name];
                const targetRot = targetRotations[name];

                mesh.rotation.x = startRot.x + (targetRot.x - startRot.x) * progress;
                mesh.rotation.y = startRot.y + (targetRot.y - startRot.y) * progress;
                mesh.rotation.z = startRot.z + (targetRot.z - startRot.z) * progress;

                if (name === "servo04") {
                    components.grip.rotation.x = mesh.rotation.x;
                } else if (name === "servo05") {
                    const targetZ = targetRot.z;
                    const startZ = startRot.z;
                    
                    const deltaZ = (targetZ - startZ) * progress;

                    components.gearl.rotation.z = startRot.z - deltaZ;
                    components.gearr.rotation.z = startRot.z + deltaZ;
                }
            });

            if (progress < 1) {
                routineAnimationRequestId = requestAnimationFrame(animateStep);
            } else {
                currentRoutineStep++;
                routineAnimationTimeout = setTimeout(() => executeRoutine(components), 100);
            }
        };

        routineAnimationRequestId = requestAnimationFrame(animateStep);
    };

    const startRoutine = (components) => {
        if (!isRoutineRunning) {
            isRoutineRunning = true;
            currentRoutineStep = 0;
            executeRoutine(components);
            updateStatus("Routine started");
        } else {
            updateStatus("Routine already running", true);
        }
    };

    // Transition function for camera
    const transitionCamera = (preset) => {
        const frameRate = 60;
        const animationDuration = 60;

        BABYLON.Animation.CreateAndStartAnimation(
            "alphaAnim", camera, "alpha", frameRate, animationDuration,
            camera.alpha, preset.alpha, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        BABYLON.Animation.CreateAndStartAnimation(
            "betaAnim", camera, "beta", frameRate, animationDuration,
            camera.beta, preset.beta, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        BABYLON.Animation.CreateAndStartAnimation(
            "radiusAnim", camera, "radius", frameRate, animationDuration,
            camera.radius, preset.radius, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        BABYLON.Animation.CreateAndStartAnimation(
            "targetXAnim", camera.target, "x", frameRate, animationDuration,
            camera.target.x, preset.target.x, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        BABYLON.Animation.CreateAndStartAnimation(
            "targetYAnim", camera.target, "y", frameRate, animationDuration,
            camera.target.y, preset.target.y, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        BABYLON.Animation.CreateAndStartAnimation(
            "targetZAnim", camera.target, "z", frameRate, animationDuration,
            camera.target.z, preset.target.z, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
    };

    // Function to perform a single step rotation - NOT USED WITH SLIDERS
    const performStepRotation = (components, target, axis, direction) => {
        // This function is no longer needed with sliders directly controlling rotation
    };

    // Keyboard controls setup
    const setupControls = (components) => {
      window.addEventListener("keydown", (event) => {
        const { waist, servo01, servo02, servo03, servo04, servo05, gearl, gearr, grip, 
                gripLinkLeft1, gripLinkLeft2, gripLinkRight1, gripLinkRight2, gear1, gear2 } = components;
        
        // Existing keyboard controls remain for direct keypress interaction
        switch (event.key.toLowerCase()) {
          case "a": waist.rotation.y -= CONFIG.rotationSpeed; break;
          case "s": waist.rotation.y += CONFIG.rotationSpeed; break;
          case "e": servo01.rotation.x -= CONFIG.rotationSpeed; break;
          case "r": servo01.rotation.x += CONFIG.rotationSpeed; break;
          case "z": servo02.rotation.x -= CONFIG.rotationSpeed; break;
          case "x": servo02.rotation.x += CONFIG.rotationSpeed; break;
          case "f": servo03.rotation.z -= CONFIG.rotationSpeed; break;
          case "g": servo03.rotation.z += CONFIG.rotationSpeed; break;
          case "c": 
            servo04.rotation.x -= CONFIG.rotationSpeed;
            grip.rotation.x -= CONFIG.rotationSpeed;
            break;
          case "v": 
            servo04.rotation.x += CONFIG.rotationSpeed;
            grip.rotation.x += CONFIG.rotationSpeed; 
            break;
          case "q": 
            servo05.rotation.z -= CONFIG.rotationSpeed;
            gearl.rotation.z -= CONFIG.rotationSpeed;
            gearr.rotation.z += CONFIG.rotationSpeed;
            break;
          case "w": 
            servo05.rotation.z += CONFIG.rotationSpeed;
            gearr.rotation.z -= CONFIG.rotationSpeed;
            gearl.rotation.z += CONFIG.rotationSpeed;
            break;
          // New controls for gears and grip links
          case "1":
            gear1.rotation.z -= CONFIG.rotationSpeed;
            gear2.rotation.z += CONFIG.rotationSpeed;
            break;
          case "2":
            gear1.rotation.z += CONFIG.rotationSpeed;
            gear2.rotation.z -= CONFIG.rotationSpeed;
            break;
          case "3":
            gripLinkLeft1.rotation.z -= CONFIG.rotationSpeed * 0.5;
            gripLinkLeft2.rotation.z += CONFIG.rotationSpeed * 0.5;
            gripLinkRight1.rotation.z -= CONFIG.rotationSpeed * 0.5;
            gripLinkRight2.rotation.z += CONFIG.rotationSpeed * 0.5;
            break;
          case "4":
            gripLinkLeft1.rotation.z += CONFIG.rotationSpeed * 0.5;
            gripLinkLeft2.rotation.z -= CONFIG.rotationSpeed * 0.5;
            gripLinkRight1.rotation.z += CONFIG.rotationSpeed * 0.5;
            gripLinkRight2.rotation.z -= CONFIG.rotationSpeed * 0.5;
            break;
        }
      });
    };

    // Configuración de controles HTML
    const setupHTMLControls = (components) => {
      // Slider de velocidad
      document.getElementById("speedSlider").addEventListener('input', (e) => {
        CONFIG.rotationSpeed = parseFloat(e.target.value);
      });
      
      // Arm component sliders
      document.getElementById("waistSlider").addEventListener('input', (e) => {
        components.waist.rotation.y = parseFloat(e.target.value);
      });
      document.getElementById("arm1Slider").addEventListener('input', (e) => {
        components.servo01.rotation.x = parseFloat(e.target.value);
      });
      document.getElementById("arm2Slider").addEventListener('input', (e) => {
        components.servo02.rotation.x = parseFloat(e.target.value);
      });
      document.getElementById("arm3Slider").addEventListener('input', (e) => {
        components.servo03.rotation.z = parseFloat(e.target.value);
      });
      document.getElementById("gripPitchSlider").addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        components.servo04.rotation.x = value;
        components.grip.rotation.x = value;
      });
      document.getElementById("gripperOpenCloseSlider").addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        components.servo05.rotation.z = value;
        components.gearl.rotation.z = -value; // Inverse for gearl
        components.gearr.rotation.z = value; // Direct for gearr
      });

      // New sliders for gears and grip links
      document.getElementById("gearSlider").addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        components.gear1.rotation.z = value;
        components.gear2.rotation.z = -value; // Inverse rotation for gear2
      });

      document.getElementById("linkAdjustSlider").addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        components.gripLinkLeft1.rotation.z = -value;
        components.gripLinkLeft2.rotation.z = value;
        components.gripLinkRight1.rotation.z = -value;
        components.gripLinkRight2.rotation.z = value;
      });
      
      // Controles de rutina
      document.getElementById("capturePosition").addEventListener('click', () => setRotation(components));
      document.getElementById("startRoutine").addEventListener('click', () => startRoutine(components));
      document.getElementById("stopRoutine").addEventListener('click', () => stopRoutine());
      document.getElementById("resetRoutine").addEventListener('click', () => resetRotations());
      document.getElementById("replayRoutine").addEventListener('click', () => startRoutine(components));
      
      // Controles de cámara
      document.getElementById("defaultView").addEventListener('click', () => transitionCamera(cameraPresets["Default"]));
      document.getElementById("frontView").addEventListener('click', () => transitionCamera(cameraPresets["Front View"]));
      document.getElementById("topView").addEventListener('click', () => transitionCamera(cameraPresets["Top View"]));
      document.getElementById("sideView").addEventListener('click', () => transitionCamera(cameraPresets["Side View"]));
    };
    
    // Main function to create the scene
    const createScene = () => {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0, 0, 0.2);
      
      camera = setupCamera(scene);
      setupLight(scene);
      setupGround(scene);
      
      const armComponents = createArmComponents(scene);
      loadSTLModels(scene, armComponents);
      
      setupHTMLControls(armComponents);
      setupControls(armComponents); // Keep keyboard controls for an alternative input method
      
      return scene;
    };

    // Scene initialization
    const scene = createScene();
    
    engine.runRenderLoop(() => {
      scene.render();
    });

    window.addEventListener('resize', () => {
      engine.resize();
    });
    
    // Actualizar estado inicial
    updateStatus("System Ready");
  </script>
</body>
</html>
